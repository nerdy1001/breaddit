"use client";

// src/component.tsx
import { useCallback, useState as useState2 } from "react";
import { useDropzone } from "react-dropzone";
import {
  classNames,
  generateClientDropzoneAccept,
  generateMimeTypes
} from "uploadthing/client";

// src/useUploadThing.ts
import { useState } from "react";
import { DANGEROUS__uploadFiles } from "uploadthing/client";

// src/utils/useEvent.ts
import React from "react";
var useInsertionEffect = typeof window !== "undefined" ? (
  // useInsertionEffect is available in React 18+
  React.useInsertionEffect || React.useLayoutEffect
) : () => {
};
function useEvent(callback) {
  const latestRef = React.useRef(
    useEvent_shouldNotBeInvokedBeforeMount
  );
  useInsertionEffect(() => {
    latestRef.current = callback;
  }, [callback]);
  const stableRef = React.useRef(null);
  if (!stableRef.current) {
    stableRef.current = function() {
      return latestRef.current.apply(this, arguments);
    };
  }
  return stableRef.current;
}
function useEvent_shouldNotBeInvokedBeforeMount() {
  throw new Error(
    "INVALID_USEEVENT_INVOCATION: the callback from useEvent cannot be invoked before the component has mounted."
  );
}

// src/utils/useFetch.ts
import { useEffect, useReducer, useRef } from "react";
function useFetch(url, options) {
  const cache = useRef({});
  const cancelRequest = useRef(false);
  const initialState = {
    error: void 0,
    data: void 0
  };
  const fetchReducer = (state2, action) => {
    switch (action.type) {
      case "loading":
        return { ...initialState };
      case "fetched":
        return { ...initialState, data: action.payload };
      case "error":
        return { ...initialState, error: action.payload };
      default:
        return state2;
    }
  };
  const [state, dispatch] = useReducer(fetchReducer, initialState);
  useEffect(() => {
    if (!url)
      return;
    cancelRequest.current = false;
    const fetchData = async () => {
      dispatch({ type: "loading" });
      if (cache.current[url]) {
        dispatch({ type: "fetched", payload: cache.current[url] });
        return;
      }
      try {
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(response.statusText);
        }
        const data = await response.json();
        cache.current[url] = data;
        if (cancelRequest.current)
          return;
        dispatch({ type: "fetched", payload: data });
      } catch (error) {
        if (cancelRequest.current)
          return;
        dispatch({ type: "error", payload: error });
      }
    };
    void fetchData();
    return () => {
      cancelRequest.current = true;
    };
  }, [url]);
  return state;
}
var useFetch_default = useFetch;

// src/useUploadThing.ts
var useEndpointMetadata = (endpoint) => {
  const { data } = useFetch_default("/api/uploadthing");
  return data == null ? void 0 : data.find((x) => x.slug === endpoint);
};
var useUploadThing = ({
  endpoint,
  onClientUploadComplete,
  onUploadError
}) => {
  const [isUploading, setUploading] = useState(false);
  const permittedFileInfo = useEndpointMetadata(endpoint);
  const startUpload = useEvent(async (files) => {
    setUploading(true);
    try {
      const res = await DANGEROUS__uploadFiles(files, endpoint);
      setUploading(false);
      onClientUploadComplete == null ? void 0 : onClientUploadComplete(res);
      return res;
    } catch (e) {
      setUploading(false);
      onUploadError == null ? void 0 : onUploadError(e);
      return;
    }
  });
  return {
    startUpload,
    isUploading,
    permittedFileInfo
  };
};

// src/component.tsx
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
var generatePermittedFileTypes = (config) => {
  const fileTypes = config ? Object.keys(config) : [];
  const maxFileCount = config ? Object.values(config).map((v) => v.maxFileCount) : [];
  return { fileTypes, multiple: maxFileCount.some((v) => v && v > 1) };
};
var capitalizeStart = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
var INTERNAL_doFormatting = (config) => {
  if (!config)
    return "";
  const allowedTypes = Object.keys(config);
  const formattedTypes = allowedTypes.map((f) => f === "blob" ? "file" : f);
  if (formattedTypes.length > 1) {
    const lastType = formattedTypes.pop();
    return `${formattedTypes.join("s, ")} and ${lastType}s`;
  }
  const key = allowedTypes[0];
  const formattedKey = formattedTypes[0];
  const { maxFileSize, maxFileCount } = config[key];
  if (maxFileCount && maxFileCount > 1) {
    return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;
  } else {
    return `${formattedKey} (${maxFileSize})`;
  }
};
var allowedContentTextLabelGenerator = (config) => {
  return capitalizeStart(INTERNAL_doFormatting(config));
};
function UploadButton(props) {
  var _a;
  const { startUpload, isUploading, permittedFileInfo } = useUploadThing({
    endpoint: props.endpoint,
    onClientUploadComplete: props.onClientUploadComplete,
    onUploadError: props.onUploadError
  });
  const { fileTypes, multiple } = generatePermittedFileTypes(
    permittedFileInfo == null ? void 0 : permittedFileInfo.config
  );
  return /* @__PURE__ */ jsxs("div", { className: "ut-flex ut-flex-col ut-gap-1 ut-items-center ut-justify-center", children: [
    /* @__PURE__ */ jsxs("label", { className: "ut-bg-blue-600 ut-rounded-md ut-w-36 ut-h-10 ut-flex ut-items-center ut-justify-center ut-cursor-pointer", children: [
      /* @__PURE__ */ jsx(
        "input",
        {
          className: "ut-hidden",
          type: "file",
          multiple,
          accept: (_a = generateMimeTypes(fileTypes ?? [])) == null ? void 0 : _a.join(", "),
          onChange: (e) => {
            if (!e.target.files)
              return;
            void startUpload(Array.from(e.target.files));
          }
        }
      ),
      /* @__PURE__ */ jsx("span", { className: "ut-px-3 ut-py-2 ut-text-white", children: isUploading ? /* @__PURE__ */ jsx(Spinner, {}) : `Choose File${multiple ? `(s)` : ``}` })
    ] }),
    /* @__PURE__ */ jsx("div", { className: "ut-h-[1.25rem]", children: fileTypes && /* @__PURE__ */ jsx("p", { className: "ut-text-xs ut-leading-5 ut-text-gray-600", children: allowedContentTextLabelGenerator(permittedFileInfo == null ? void 0 : permittedFileInfo.config) }) })
  ] });
}
var Spinner = () => {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      className: "ut-animate-spin ut-h-5 ut-w-5 ut-text-white",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 576 512",
      children: /* @__PURE__ */ jsx(
        "path",
        {
          fill: "currentColor",
          d: "M256 32C256 14.33 270.3 0 288 0C429.4 0 544 114.6 544 256C544 302.6 531.5 346.4 509.7 384C500.9 399.3 481.3 404.6 465.1 395.7C450.7 386.9 445.5 367.3 454.3 351.1C470.6 323.8 480 291 480 255.1C480 149.1 394 63.1 288 63.1C270.3 63.1 256 49.67 256 31.1V32z"
        }
      )
    }
  );
};
var UploadDropzone = (props) => {
  const { startUpload, isUploading, permittedFileInfo } = useUploadThing({
    endpoint: props.endpoint,
    onClientUploadComplete: props.onClientUploadComplete,
    onUploadError: props.onUploadError
  });
  const [files, setFiles] = useState2([]);
  const onDrop = useCallback((acceptedFiles) => {
    setFiles(acceptedFiles);
  }, []);
  const { fileTypes } = generatePermittedFileTypes(permittedFileInfo == null ? void 0 : permittedFileInfo.config);
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: fileTypes ? generateClientDropzoneAccept(fileTypes) : void 0
  });
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: classNames(
        "ut-mt-2 ut-flex ut-justify-center ut-rounded-lg ut-border ut-border-dashed ut-border-gray-900/25 ut-px-6 ut-py-10",
        isDragActive ? "ut-bg-blue-600/10" : ""
      ),
      children: /* @__PURE__ */ jsxs("div", { className: "text-center", ...getRootProps(), children: [
        /* @__PURE__ */ jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20",
            className: "ut-mx-auto ut-h-12 ut-w-12 ut-text-gray-400",
            children: /* @__PURE__ */ jsx(
              "path",
              {
                fill: "currentColor",
                fillRule: "evenodd",
                d: "M5.5 17a4.5 4.5 0 0 1-1.44-8.765a4.5 4.5 0 0 1 8.302-3.046a3.5 3.5 0 0 1 4.504 4.272A4 4 0 0 1 15 17H5.5Zm3.75-2.75a.75.75 0 0 0 1.5 0V9.66l1.95 2.1a.75.75 0 1 0 1.1-1.02l-3.25-3.5a.75.75 0 0 0-1.1 0l-3.25 3.5a.75.75 0 1 0 1.1 1.02l1.95-2.1v4.59Z",
                clipRule: "evenodd"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxs("div", { className: "ut-mt-4 ut-flex ut-text-sm ut-leading-6 ut-text-gray-600", children: [
          /* @__PURE__ */ jsxs(
            "label",
            {
              htmlFor: "file-upload",
              className: "ut-relative ut-cursor-pointer ut-font-semibold ut-text-blue-600 focus-within:ut-outline-none focus-within:ut-ring-2 focus-within:ut-ring-blue-600 focus-within:ut-ring-offset-2 hover:ut-text-blue-500",
              children: [
                `Choose files`,
                /* @__PURE__ */ jsx("input", { className: "ut-sr-only", ...getInputProps() })
              ]
            }
          ),
          /* @__PURE__ */ jsx("p", { className: "ut-pl-1", children: `or drag and drop` })
        ] }),
        /* @__PURE__ */ jsx("div", { className: "ut-h-[1.25rem]", children: /* @__PURE__ */ jsx("p", { className: "ut-text-xs ut-leading-5 ut-text-gray-600", children: allowedContentTextLabelGenerator(permittedFileInfo == null ? void 0 : permittedFileInfo.config) }) }),
        files.length > 0 && /* @__PURE__ */ jsx("div", { className: "ut-mt-4 ut-flex ut-items-center ut-justify-center", children: /* @__PURE__ */ jsx(
          "button",
          {
            className: "ut-bg-blue-600 ut-rounded-md ut-w-36 ut-h-10 ut-flex ut-items-center ut-justify-center",
            onClick: (e) => {
              e.preventDefault();
              e.stopPropagation();
              if (!files)
                return;
              void startUpload(files);
            },
            children: /* @__PURE__ */ jsx("span", { className: "ut-px-3 ut-py-2 ut-text-white", children: isUploading ? /* @__PURE__ */ jsx(Spinner, {}) : `Upload ${files.length} file${files.length === 1 ? "" : "s"}` })
          }
        ) })
      ] })
    }
  );
};
export {
  UploadButton,
  UploadDropzone
};
//# sourceMappingURL=index.mjs.map