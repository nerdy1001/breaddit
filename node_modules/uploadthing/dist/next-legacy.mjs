var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "uploadthing",
      version: "4.0.0",
      license: "MIT",
      exports: {
        "./package.json": "./package.json",
        "./client": {
          import: "./dist/client.mjs",
          types: "./dist/client.d.ts"
        },
        "./server": {
          import: "./dist/server.mjs",
          types: "./dist/server.d.ts",
          default: "./dist/server.mjs"
        },
        "./next": {
          import: "./dist/next.mjs",
          types: "./dist/next.d.ts"
        },
        "./next-legacy": {
          import: "./dist/next-legacy.mjs",
          types: "./dist/next-legacy.d.ts"
        }
      },
      files: [
        "dist"
      ],
      typesVersions: {
        "*": {
          "*": [
            "dist/*"
          ]
        }
      },
      scripts: {
        lint: 'eslint "**/*.{ts,tsx}" --max-warnings 0',
        build: "tsup",
        prebuild: "tsup",
        clean: "git clean -xdf dist node_modules",
        dev: "tsup --watch",
        test: "vitest run",
        "test:watch": "vitest",
        typecheck: "tsc --noEmit"
      },
      dependencies: {
        "mime-types": "^2.1.35"
      },
      devDependencies: {
        "@types/mime-types": "2.1.1",
        "@types/node": "18.16.0",
        "@uploadthing/eslint-config": "0.1.0",
        "@uploadthing/tsconfig": "0.1.0",
        "@uploadthing/tsup-config": "0.1.0",
        eslint: "^8.40.0",
        next: "13.4.4",
        tsup: "6.7.0",
        "type-fest": "^3.11.0",
        typescript: "5.1.0-beta",
        vitest: "^0.30.1"
      },
      publishConfig: {
        access: "public"
      }
    };
  }
});

// src/upload-builder.ts
function internalCreateBuilder(initDef = {}) {
  const _def = {
    // Default router config
    routerConfig: {
      image: {
        maxFileSize: "4MB"
      }
    },
    middleware: () => ({}),
    // Overload with properties passed in
    ...initDef
  };
  return {
    middleware(userMiddleware) {
      return internalCreateBuilder({
        ..._def,
        middleware: userMiddleware
      });
    },
    onUploadComplete(userUploadComplete) {
      return {
        _def,
        resolver: userUploadComplete
      };
    }
  };
}
function createBuilder() {
  return (input) => {
    return internalCreateBuilder({ routerConfig: input });
  };
}

// src/constants.ts
var packageJson = require_package();
if (!packageJson.version)
  throw new Error("no version found in package.json");
var UPLOADTHING_VERSION = packageJson.version;

// src/utils.ts
import { lookup } from "mime-types";
function isRouteArray(routeConfig) {
  return Array.isArray(routeConfig);
}
var getDefaultSizeForType = (fileType) => {
  if (fileType === "image")
    return "4MB";
  if (fileType === "video")
    return "16MB";
  if (fileType === "audio")
    return "8MB";
  if (fileType === "blob")
    return "8MB";
  return "4MB";
};
var fillInputRouteConfig = (routeConfig) => {
  if (isRouteArray(routeConfig)) {
    return routeConfig.reduce((acc, fileType) => {
      acc[fileType] = {
        // Apply defaults
        maxFileSize: getDefaultSizeForType(fileType),
        maxFileCount: 1
      };
      return acc;
    }, {});
  }
  const newConfig = {};
  Object.keys(routeConfig).forEach((key) => {
    const value = routeConfig[key];
    if (!value)
      throw new Error("Invalid config during fill");
    const defaultValues = {
      maxFileSize: getDefaultSizeForType(key),
      maxFileCount: 1
    };
    newConfig[key] = { ...defaultValues, ...value };
  }, {});
  return newConfig;
};
var getTypeFromFileName = (fileName, allowedTypes) => {
  const mimeType = lookup(fileName);
  if (!mimeType) {
    throw new Error(
      `Could not determine type for ${fileName}, presigned URL generation failed`
    );
  }
  const type = mimeType.split("/")[0];
  if (!allowedTypes.includes(type)) {
    if (allowedTypes.includes("blob")) {
      return "blob";
    } else {
      throw new Error(`File type ${type} not allowed for ${fileName}`);
    }
  }
  return type;
};

// src/internal/handler.ts
var fileCountLimitHit = (files, routeConfig) => {
  const counts = {
    image: 0,
    video: 0,
    audio: 0,
    blob: 0
  };
  files.forEach((file) => {
    const type = getTypeFromFileName(
      file,
      Object.keys(routeConfig)
    );
    counts[type] += 1;
  });
  return Object.keys(counts).some((key) => {
    var _a;
    const count = counts[key];
    if (count === 0)
      return false;
    const limit = (_a = routeConfig[key]) == null ? void 0 : _a.maxFileCount;
    if (!limit) {
      console.error(routeConfig, key);
      throw new Error("invalid config during file count");
    }
    return count > limit;
  });
};
var generateUploadThingURL = (path) => {
  const host = process.env.CUSTOM_INFRA_URL ?? "https://uploadthing.com";
  return `${host}${path}`;
};
if (process.env.NODE_ENV !== "development") {
  console.log("[UT] UploadThing dev server is now running!");
}
var isValidResponse = (response) => {
  if (!response.ok)
    return false;
  if (response.status >= 400)
    return false;
  if (!response.headers.has("x-uploadthing-version"))
    return false;
  return true;
};
var withExponentialBackoff = async (doTheThing, MAXIMUM_BACKOFF_MS = 64 * 1e3, MAX_RETRIES = 20) => {
  let tries = 0;
  let backoffMs = 500;
  let backoffFuzzMs = 0;
  let result = null;
  while (tries <= MAX_RETRIES) {
    result = await doTheThing();
    if (result !== null)
      return result;
    tries += 1;
    backoffMs = Math.min(MAXIMUM_BACKOFF_MS, backoffMs * 2);
    backoffFuzzMs = Math.floor(Math.random() * 500);
    if (tries > 3) {
      console.error(
        `[UT] Call unsuccessful after ${tries} tries. Retrying in ${Math.floor(
          backoffMs / 1e3
        )} seconds...`
      );
    }
    await new Promise((r) => setTimeout(r, backoffMs + backoffFuzzMs));
  }
  return null;
};
var conditionalDevServer = async (fileKey) => {
  if (process.env.NODE_ENV !== "development")
    return;
  const queryUrl = generateUploadThingURL(`/api/pollUpload/${fileKey}`);
  const fileData = await withExponentialBackoff(async () => {
    const res = await fetch(queryUrl);
    const json = await res.json();
    if (json.status !== "done")
      return null;
    const file = json.fileData;
    let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
    if (!callbackUrl.startsWith("http"))
      callbackUrl = "http://" + callbackUrl;
    console.log("[UT] SIMULATING FILE UPLOAD WEBHOOK CALLBACK", callbackUrl);
    const response = await fetch(callbackUrl, {
      method: "POST",
      body: JSON.stringify({
        status: "uploaded",
        metadata: JSON.parse(file.metadata ?? "{}"),
        file: {
          url: `https://uploadthing.com/f/${encodeURIComponent(fileKey ?? "")}`,
          key: fileKey ?? "",
          name: file.fileName
        }
      }),
      headers: {
        "uploadthing-hook": "callback"
      }
    });
    if (isValidResponse(response)) {
      console.log("[UT] Successfully simulated callback for file", fileKey);
    } else {
      console.error(
        "[UT] Failed to simulate callback for file. Is your webhook configured correctly?",
        fileKey
      );
    }
    return file;
  });
  if (fileData !== null)
    return fileData;
  console.error(`[UT] Failed to simulate callback for file ${fileKey}`);
  throw new Error("File took too long to upload");
};
var GET_DEFAULT_URL = () => {
  const vcurl = process.env.VERCEL_URL;
  if (vcurl)
    return `https://${vcurl}/api/uploadthing`;
  const uturl = process.env.UPLOADTHING_URL;
  if (uturl)
    return `${uturl}/api/uploadthing`;
  return `http://localhost:${process.env.PORT ?? 3e3}/api/uploadthing`;
};
var buildRequestHandler = (opts) => {
  return async (input) => {
    const { router, config } = opts;
    const preferredOrEnvSecret = (config == null ? void 0 : config.uploadthingSecret) ?? process.env.UPLOADTHING_SECRET;
    const { uploadthingHook, slug, req, res, actionType } = input;
    if (!slug)
      throw new Error("we need a slug");
    if (!preferredOrEnvSecret) {
      throw new Error(
        `Please set your preferred secret in ${slug} router's config or set UPLOADTHING_SECRET in your env file`
      );
    }
    const uploadable = router[slug];
    if (!uploadable) {
      return { status: 404 };
    }
    const reqBody = await req.json();
    if (uploadthingHook && uploadthingHook === "callback") {
      await uploadable.resolver({
        file: reqBody.file,
        metadata: reqBody.metadata
      });
      return { status: 200 };
    }
    if (!actionType || actionType !== "upload") {
      return { status: 404 };
    }
    try {
      const { files } = reqBody;
      const metadata = await uploadable._def.middleware(req, res);
      if (!Array.isArray(files) || !files.every((f) => typeof f === "string"))
        throw new Error("Need file array");
      const parsedConfig = fillInputRouteConfig(
        uploadable._def.routerConfig
      );
      const limitHit = fileCountLimitHit(files, parsedConfig);
      if (limitHit)
        throw new Error("Too many files");
      const uploadthingApiResponse = await fetch(
        generateUploadThingURL("/api/prepareUpload"),
        {
          method: "POST",
          body: JSON.stringify({
            files,
            routeConfig: parsedConfig,
            metadata,
            callbackUrl: (config == null ? void 0 : config.callbackUrl) ?? GET_DEFAULT_URL(),
            callbackSlug: slug
          }),
          headers: {
            "Content-Type": "application/json",
            "x-uploadthing-api-key": preferredOrEnvSecret,
            "x-uploadthing-version": UPLOADTHING_VERSION
          }
        }
      );
      if (!uploadthingApiResponse.ok) {
        console.error("[UT] unable to get presigned urls");
        try {
          const error = await uploadthingApiResponse.json();
          console.error(error);
        } catch (e) {
          console.error("[UT] unable to parse response");
        }
        throw new Error("ending upload");
      }
      const parsedResponse = await uploadthingApiResponse.json();
      if (process.env.NODE_ENV === "development") {
        for (const file of parsedResponse) {
          void conditionalDevServer(file.key);
        }
      }
      return { body: parsedResponse, status: 200 };
    } catch (e) {
      console.error("[UT] middleware failed to run");
      console.error(e);
      return { status: 400, message: e.toString() };
    }
  };
};
var buildPermissionsInfoHandler = (opts) => {
  return () => {
    const r = opts.router;
    const permissions = Object.keys(r).map((k) => {
      const route = r[k];
      const config = fillInputRouteConfig(route._def.routerConfig);
      return {
        slug: k,
        config
      };
    });
    return permissions;
  };
};

// src/next/core/page.ts
var createNextPageApiHandler = (opts) => {
  const requestHandler = buildRequestHandler(opts);
  const getBuildPerms = buildPermissionsInfoHandler(opts);
  return async (req, res) => {
    if (req.method === "GET") {
      const perms = getBuildPerms();
      res.status(200).json(perms);
      return;
    }
    const params = req.query;
    const uploadthingHook = req.headers["uploadthing-hook"];
    const slug = params["slug"];
    const actionType = params["actionType"];
    if (slug && typeof slug !== "string")
      return res.status(400).send("`slug` must not be an array");
    if (actionType && typeof actionType !== "string")
      return res.status(400).send("`actionType` must not be an array");
    if (uploadthingHook && typeof uploadthingHook !== "string")
      return res.status(400).send("`uploadthingHook` must not be an array");
    if (typeof req.body !== "string")
      return res.status(400).send("Request body must be a JSON string");
    const standardRequest = {
      ...req,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      json: () => Promise.resolve(JSON.parse(req.body)),
      headers: {
        get: (key) => req.headers[key]
      }
    };
    const response = await requestHandler({
      uploadthingHook,
      slug,
      actionType,
      req: standardRequest,
      res
    });
    res.status(response.status);
    res.setHeader("x-uploadthing-version", UPLOADTHING_VERSION);
    if (response.status === 200) {
      return res.json(response.body);
    }
    return res.send(response.message ?? "Unable to upload file.");
  };
};

// next-legacy.ts
var createUploadthing = () => createBuilder();
export {
  createNextPageApiHandler,
  createUploadthing
};
//# sourceMappingURL=next-legacy.mjs.map