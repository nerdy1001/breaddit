{"version":3,"sources":["../package.json","../src/upload-builder.ts","../src/types.ts","../src/helper-functions.ts","../src/constants.ts","../src/utils.ts","../src/internal/handler.ts","../server.ts"],"sourcesContent":["{\n  \"name\": \"uploadthing\",\n  \"version\": \"4.0.0\",\n  \"license\": \"MIT\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \"./client\": {\n      \"import\": \"./dist/client.mjs\",\n      \"types\": \"./dist/client.d.ts\"\n    },\n    \"./server\": {\n      \"import\": \"./dist/server.mjs\",\n      \"types\": \"./dist/server.d.ts\",\n      \"default\": \"./dist/server.mjs\"\n    },\n    \"./next\": {\n      \"import\": \"./dist/next.mjs\",\n      \"types\": \"./dist/next.d.ts\"\n    },\n    \"./next-legacy\": {\n      \"import\": \"./dist/next-legacy.mjs\",\n      \"types\": \"./dist/next-legacy.d.ts\"\n    }\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"typesVersions\": {\n    \"*\": {\n      \"*\": [\n        \"dist/*\"\n      ]\n    }\n  },\n  \"scripts\": {\n    \"lint\": \"eslint \\\"**/*.{ts,tsx}\\\" --max-warnings 0\",\n    \"build\": \"tsup\",\n    \"prebuild\": \"tsup\",\n    \"clean\": \"git clean -xdf dist node_modules\",\n    \"dev\": \"tsup --watch\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"mime-types\": \"^2.1.35\"\n  },\n  \"devDependencies\": {\n    \"@types/mime-types\": \"2.1.1\",\n    \"@types/node\": \"18.16.0\",\n    \"@uploadthing/eslint-config\": \"0.1.0\",\n    \"@uploadthing/tsconfig\": \"0.1.0\",\n    \"@uploadthing/tsup-config\": \"0.1.0\",\n    \"eslint\": \"^8.40.0\",\n    \"next\": \"13.4.4\",\n    \"tsup\": \"6.7.0\",\n    \"type-fest\": \"^3.11.0\",\n    \"typescript\": \"5.1.0-beta\",\n    \"vitest\": \"^0.30.1\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  }\n}\n","import type {\n  AnyRuntime,\n  FileRouterInputConfig,\n  UnsetMarker,\n  UploadBuilder,\n  UploadBuilderDef,\n  Uploader,\n} from \"./types\";\n\nfunction internalCreateBuilder<TRuntime extends AnyRuntime = \"web\">(\n  initDef: Partial<UploadBuilderDef<TRuntime>> = {},\n): UploadBuilder<{\n  _metadata: UnsetMarker;\n  _runtime: TRuntime;\n}> {\n  const _def: UploadBuilderDef<TRuntime> = {\n    // Default router config\n    routerConfig: {\n      image: {\n        maxFileSize: \"4MB\",\n      },\n    },\n\n    middleware: () => ({}),\n\n    // Overload with properties passed in\n    ...initDef,\n  };\n\n  return {\n    middleware(userMiddleware) {\n      return internalCreateBuilder({\n        ..._def,\n        middleware: userMiddleware,\n      }) as UploadBuilder<{ _metadata: any; _runtime: TRuntime }>;\n    },\n    onUploadComplete(userUploadComplete) {\n      return {\n        _def,\n        resolver: userUploadComplete,\n      } as Uploader<{ _metadata: any; _runtime: TRuntime }>;\n    },\n  };\n}\n\ntype InOut<TRuntime extends AnyRuntime = \"web\"> = (\n  input: FileRouterInputConfig,\n) => UploadBuilder<{\n  _metadata: UnsetMarker;\n  _runtime: TRuntime;\n}>;\n\nexport function createBuilder<\n  TRuntime extends AnyRuntime = \"web\",\n>(): InOut<TRuntime> {\n  return (input: FileRouterInputConfig) => {\n    return internalCreateBuilder<TRuntime>({ routerConfig: input });\n  };\n}\n","import type { NextApiRequest, NextApiResponse } from \"next\";\nimport type { NextRequest } from \"next/server\";\n\n// Utils\nexport const unsetMarker = \"unsetMarker\" as \"unsetMarker\" & {\n  __brand: \"unsetMarker\";\n};\nexport type UnsetMarker = typeof unsetMarker;\n\ntype Simplify<TType> = { [TKey in keyof TType]: TType[TKey] } & {};\n\nexport type MaybePromise<TType> = TType | Promise<TType>;\n\n// Package\nexport type AnyRuntime = \"app\" | \"pages\" | \"web\";\nexport interface AnyParams {\n  _metadata: any; // imaginary field used to bind metadata return type to an Upload resolver\n  _runtime: any;\n}\n\nexport type UploadedFile = {\n  name: string;\n  key: string;\n  url: string;\n  size: number;\n};\n\nexport type AllowedFileType = \"image\" | \"video\" | \"audio\" | \"blob\";\n\ntype PowOf2 = 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024;\nexport type SizeUnit = \"B\" | \"KB\" | \"MB\" | \"GB\";\nexport type FileSize = `${PowOf2}${SizeUnit}`;\n\ntype RouteConfig = {\n  maxFileSize: FileSize;\n  maxFileCount: number;\n};\n\nexport type ExpandedRouteConfig = Partial<Record<AllowedFileType, RouteConfig>>;\n\ntype PartialRouteConfig = Partial<\n  Record<AllowedFileType, Partial<RouteConfig>>\n>;\n\nexport type FileRouterInputConfig = AllowedFileType[] | PartialRouteConfig;\n\ntype ResolverOptions<TParams extends AnyParams> = {\n  metadata: Simplify<\n    TParams[\"_metadata\"] extends UnsetMarker ? undefined : TParams[\"_metadata\"]\n  >;\n\n  file: UploadedFile;\n};\n\ntype MiddlewareFnArgs<TRuntime> = TRuntime extends \"web\"\n  ? { req: Request; res: never }\n  : TRuntime extends \"app\"\n  ? { req: NextRequest; res: never }\n  : { req: NextApiRequest; res: NextApiResponse };\n\ntype MiddlewareFn<\n  TOutput extends Record<string, unknown>,\n  TRuntime extends string,\n> = MiddlewareFnArgs<TRuntime>[\"res\"] extends never\n  ? (req: MiddlewareFnArgs<TRuntime>[\"req\"]) => MaybePromise<TOutput>\n  : (\n      req: MiddlewareFnArgs<TRuntime>[\"req\"],\n      res: MiddlewareFnArgs<TRuntime>[\"res\"],\n    ) => MaybePromise<TOutput>;\n\nexport type ReqMiddlewareFn<TOutput extends Record<string, unknown>> =\n  MiddlewareFn<TOutput, \"web\">;\nexport type NextReqMiddlewareFn<TOutput extends Record<string, unknown>> =\n  MiddlewareFn<TOutput, \"app\">;\nexport type NextApiMiddlewareFn<TOutput extends Record<string, unknown>> =\n  MiddlewareFn<TOutput, \"pages\">;\n\ntype ResolverFn<TParams extends AnyParams> = (\n  opts: ResolverOptions<TParams>,\n) => MaybePromise<void>;\n\nexport interface UploadBuilder<TParams extends AnyParams> {\n  middleware: <TOutput extends Record<string, unknown>>(\n    fn: MiddlewareFn<TOutput, TParams[\"_runtime\"]>,\n  ) => UploadBuilder<{\n    _metadata: TOutput;\n    _runtime: TParams[\"_runtime\"];\n  }>;\n\n  onUploadComplete: (fn: ResolverFn<TParams>) => Uploader<TParams>;\n}\n\nexport type UploadBuilderDef<TRuntime extends AnyRuntime> = {\n  routerConfig: FileRouterInputConfig;\n  middleware: MiddlewareFn<{}, TRuntime>;\n};\n\nexport interface Uploader<TParams extends AnyParams> {\n  _def: TParams & UploadBuilderDef<TParams[\"_runtime\"]>;\n  resolver: ResolverFn<TParams>;\n}\n\nexport type FileRouter<TParams extends AnyParams = AnyParams> = Record<\n  string,\n  Uploader<TParams>\n>;\n","import { UPLOADTHING_VERSION } from \"./constants\";\nimport { generateUploadThingURL } from \"./internal/handler\";\n\nconst UT_SECRET = process.env.UPLOADTHING_SECRET;\n\n/**\n * Request to delete files from UploadThing storage.\n * @param {string | string[]} fileKeys\n * @example\n * await deleteFiles(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n * @example\n * await deleteFiles([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n */\nexport const deleteFiles = async (fileKeys: string[] | string) => {\n  if (!Array.isArray(fileKeys)) fileKeys = [fileKeys];\n  if (!UT_SECRET) throw new Error(\"Missing UPLOADTHING_SECRET env variable.\");\n\n  const res = await fetch(generateUploadThingURL(\"/api/deleteFile\"), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-uploadthing-api-key\": UT_SECRET,\n      \"x-uploadthing-version\": UPLOADTHING_VERSION,\n    },\n    body: JSON.stringify({ fileKeys }),\n  });\n  if (!res.ok) {\n    throw new Error(\"Failed to delete files\");\n  }\n  return res.json() as Promise<{ success: boolean }>;\n};\n\n/**\n * Request file URLs from UploadThing storage.\n * @param {string | string[]} fileKeys\n * @example\n * const data = await getFileUrls(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n * console.log(data); // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\"}]\n *\n * @example\n * const data = await getFileUrls([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n * console.log(data) // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\" },{key: \"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\", url: \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"}]\n */\nexport const getFileUrls = async (fileKeys: string[] | string) => {\n  if (!Array.isArray(fileKeys)) fileKeys = [fileKeys];\n  if (!UT_SECRET) throw new Error(\"Missing UPLOADTHING_SECRET env variable.\");\n\n  const res = await fetch(generateUploadThingURL(\"/api/getFileUrl\"), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-uploadthing-api-key\": UT_SECRET,\n      \"x-uploadthing-version\": UPLOADTHING_VERSION,\n    },\n    body: JSON.stringify({ fileKeys }),\n  });\n  if (!res.ok) {\n    throw new Error(\"Failed to get file urls\");\n  }\n  return res.json().then(({ data }) => data as { key: string; url: string }[]);\n};\n","import type { PackageJson } from \"type-fest\";\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst packageJson = require(\"../package.json\") as PackageJson;\nif (!packageJson.version) throw new Error(\"no version found in package.json\");\nexport const UPLOADTHING_VERSION = packageJson.version;\n","import { lookup } from \"mime-types\";\n\nimport type {\n  AllowedFileType,\n  ExpandedRouteConfig,\n  FileRouterInputConfig,\n  FileSize,\n} from \"./types\";\n\nfunction isRouteArray(\n  routeConfig: FileRouterInputConfig,\n): routeConfig is AllowedFileType[] {\n  return Array.isArray(routeConfig);\n}\n\nconst getDefaultSizeForType = (fileType: AllowedFileType): FileSize => {\n  if (fileType === \"image\") return \"4MB\";\n  if (fileType === \"video\") return \"16MB\";\n  if (fileType === \"audio\") return \"8MB\";\n  if (fileType === \"blob\") return \"8MB\";\n\n  return \"4MB\";\n};\n\n/**\n * This function takes in the user's input and \"upscales\" it to a full config\n *\n * Example:\n * ```ts\n * [\"image\"] => { image: { maxFileSize: \"4MB\", limit: 1 } }\n * ```\n */\nexport const fillInputRouteConfig = (\n  routeConfig: FileRouterInputConfig,\n): ExpandedRouteConfig => {\n  // If array, apply defaults\n  if (isRouteArray(routeConfig)) {\n    return routeConfig.reduce((acc, fileType) => {\n      acc[fileType] = {\n        // Apply defaults\n        maxFileSize: getDefaultSizeForType(fileType),\n        maxFileCount: 1,\n      };\n      return acc;\n    }, {} as ExpandedRouteConfig);\n  }\n\n  // Backfill defaults onto config\n  const newConfig: ExpandedRouteConfig = {};\n  (Object.keys(routeConfig) as AllowedFileType[]).forEach((key) => {\n    const value = routeConfig[key];\n    if (!value) throw new Error(\"Invalid config during fill\");\n\n    const defaultValues = {\n      maxFileSize: getDefaultSizeForType(key),\n      maxFileCount: 1,\n    };\n\n    newConfig[key] = { ...defaultValues, ...value };\n  }, {} as ExpandedRouteConfig);\n\n  return newConfig;\n};\n\nexport const getTypeFromFileName = (\n  fileName: string,\n  allowedTypes: AllowedFileType[],\n) => {\n  const mimeType = lookup(fileName);\n  if (!mimeType) {\n    throw new Error(\n      `Could not determine type for ${fileName}, presigned URL generation failed`,\n    );\n  }\n\n  const type = mimeType.split(\"/\")[0] as AllowedFileType;\n\n  if (!allowedTypes.includes(type)) {\n    // Blob is a catch-all for any file type not explicitly supported\n    if (allowedTypes.includes(\"blob\")) {\n      return \"blob\";\n    } else {\n      throw new Error(`File type ${type} not allowed for ${fileName}`);\n    }\n  }\n\n  return type;\n};\n","import type { NextApiResponse } from \"next\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport type {\n  AllowedFileType,\n  AnyRuntime,\n  ExpandedRouteConfig,\n  FileRouter,\n  UploadedFile,\n} from \"../types\";\nimport {\n  getTypeFromFileName,\n  fillInputRouteConfig as parseAndExpandInputConfig,\n} from \"../utils\";\nimport type { FileData } from \"./types\";\n\nconst UNITS = [\"B\", \"KB\", \"MB\", \"GB\"] as const;\ntype SizeUnit = (typeof UNITS)[number];\n\nexport const fileSizeToBytes = (input: string) => {\n  const regex = new RegExp(`^(\\\\d+)(\\\\.\\\\d+)?\\\\s*(${UNITS.join(\"|\")})$`, \"i\");\n  const match = input.match(regex);\n\n  if (!match) {\n    return new Error(\"Invalid file size format\");\n  }\n\n  const sizeValue = parseFloat(match[1]);\n  const sizeUnit = match[3].toUpperCase() as SizeUnit;\n\n  if (!UNITS.includes(sizeUnit)) {\n    throw new Error(\"Invalid file size unit\");\n  }\n  const bytes = sizeValue * Math.pow(1024, UNITS.indexOf(sizeUnit));\n  return Math.floor(bytes);\n};\n\nconst fileCountLimitHit = (\n  files: string[],\n  routeConfig: ExpandedRouteConfig,\n) => {\n  const counts: Record<AllowedFileType, number> = {\n    image: 0,\n    video: 0,\n    audio: 0,\n    blob: 0,\n  };\n\n  files.forEach((file) => {\n    const type = getTypeFromFileName(\n      file,\n      Object.keys(routeConfig) as AllowedFileType[],\n    );\n    counts[type] += 1;\n  });\n\n  return Object.keys(counts).some((key) => {\n    const count = counts[key as AllowedFileType];\n    if (count === 0) return false;\n\n    const limit = routeConfig[key as AllowedFileType]?.maxFileCount;\n    if (!limit) {\n      console.error(routeConfig, key);\n      throw new Error(\"invalid config during file count\");\n    }\n\n    return count > limit;\n  });\n};\n\nexport const generateUploadThingURL = (path: `/${string}`) => {\n  const host = process.env.CUSTOM_INFRA_URL ?? \"https://uploadthing.com\";\n  return `${host}${path}`;\n};\n\nif (process.env.NODE_ENV !== \"development\") {\n  console.log(\"[UT] UploadThing dev server is now running!\");\n}\n\nconst isValidResponse = (response: Response) => {\n  if (!response.ok) return false;\n  if (response.status >= 400) return false;\n  if (!response.headers.has(\"x-uploadthing-version\")) return false;\n\n  return true;\n};\n\nconst withExponentialBackoff = async <T>(\n  doTheThing: () => Promise<T | null>,\n  MAXIMUM_BACKOFF_MS = 64 * 1000,\n  MAX_RETRIES = 20,\n): Promise<T | null> => {\n  let tries = 0;\n  let backoffMs = 500;\n  let backoffFuzzMs = 0;\n\n  let result = null;\n  while (tries <= MAX_RETRIES) {\n    result = await doTheThing();\n    if (result !== null) return result;\n\n    tries += 1;\n    backoffMs = Math.min(MAXIMUM_BACKOFF_MS, backoffMs * 2);\n    backoffFuzzMs = Math.floor(Math.random() * 500);\n\n    if (tries > 3) {\n      console.error(\n        `[UT] Call unsuccessful after ${tries} tries. Retrying in ${Math.floor(\n          backoffMs / 1000,\n        )} seconds...`,\n      );\n    }\n\n    await new Promise((r) => setTimeout(r, backoffMs + backoffFuzzMs));\n  }\n\n  return null;\n};\n\nconst conditionalDevServer = async (fileKey: string) => {\n  if (process.env.NODE_ENV !== \"development\") return;\n\n  const queryUrl = generateUploadThingURL(`/api/pollUpload/${fileKey}`);\n\n  const fileData = await withExponentialBackoff(async () => {\n    const res = await fetch(queryUrl);\n    const json = (await res.json()) as\n      | { status: \"done\"; fileData: FileData }\n      | { status: \"something else\" };\n\n    if (json.status !== \"done\") return null;\n\n    const file = json.fileData;\n\n    let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;\n    if (!callbackUrl.startsWith(\"http\")) callbackUrl = \"http://\" + callbackUrl;\n\n    console.log(\"[UT] SIMULATING FILE UPLOAD WEBHOOK CALLBACK\", callbackUrl);\n\n    const response = await fetch(callbackUrl, {\n      method: \"POST\",\n      body: JSON.stringify({\n        status: \"uploaded\",\n        metadata: JSON.parse(file.metadata ?? \"{}\") as FileData[\"metadata\"],\n        file: {\n          url: `https://uploadthing.com/f/${encodeURIComponent(fileKey ?? \"\")}`,\n          key: fileKey ?? \"\",\n          name: file.fileName,\n        },\n      }),\n      headers: {\n        \"uploadthing-hook\": \"callback\",\n      },\n    });\n    if (isValidResponse(response)) {\n      console.log(\"[UT] Successfully simulated callback for file\", fileKey);\n    } else {\n      console.error(\n        \"[UT] Failed to simulate callback for file. Is your webhook configured correctly?\",\n        fileKey,\n      );\n    }\n    return file;\n  });\n\n  if (fileData !== null) return fileData;\n\n  console.error(`[UT] Failed to simulate callback for file ${fileKey}`);\n  throw new Error(\"File took too long to upload\");\n};\n\nconst GET_DEFAULT_URL = () => {\n  /**\n   * Use VERCEL_URL as the default callbackUrl if it's set\n   * they don't set the protocol, so we need to add it\n   * User can override this with the UPLOADTHING_URL env var,\n   * if they do, they should include the protocol\n   *\n   * The pathname must be /api/uploadthing\n   * since we call that via webhook, so the user\n   * should not override that. Just the protocol and host\n   */\n  const vcurl = process.env.VERCEL_URL;\n  if (vcurl) return `https://${vcurl}/api/uploadthing`; // SSR should use vercel url\n  const uturl = process.env.UPLOADTHING_URL;\n  if (uturl) return `${uturl}/api/uploadthing`;\n\n  return `http://localhost:${process.env.PORT ?? 3000}/api/uploadthing`; // dev SSR should use localhost\n};\n\nexport type RouterWithConfig<TRouter extends FileRouter> = {\n  router: TRouter;\n  config?: {\n    callbackUrl?: string;\n    uploadthingId?: string;\n    uploadthingSecret?: string;\n  };\n};\n\nexport const buildRequestHandler = <\n  TRouter extends FileRouter,\n  TRuntime extends AnyRuntime,\n>(\n  opts: RouterWithConfig<TRouter>,\n) => {\n  return async (input: {\n    uploadthingHook?: string;\n    slug?: string;\n    actionType?: string;\n    req: Partial<Request> & { json: Request[\"json\"] };\n    res?: TRuntime extends \"pages\" ? NextApiResponse : undefined;\n  }) => {\n    const { router, config } = opts;\n    const preferredOrEnvSecret =\n      config?.uploadthingSecret ?? process.env.UPLOADTHING_SECRET;\n    const { uploadthingHook, slug, req, res, actionType } = input;\n\n    if (!slug) throw new Error(\"we need a slug\");\n\n    if (!preferredOrEnvSecret) {\n      throw new Error(\n        `Please set your preferred secret in ${slug} router's config or set UPLOADTHING_SECRET in your env file`,\n      );\n    }\n\n    const uploadable = router[slug];\n    if (!uploadable) {\n      return { status: 404 };\n    }\n\n    const reqBody = (await req.json()) as {\n      file: UploadedFile;\n      files: unknown;\n      metadata: Record<string, unknown>;\n    };\n\n    if (uploadthingHook && uploadthingHook === \"callback\") {\n      // This is when we receive the webhook from uploadthing\n      await uploadable.resolver({\n        file: reqBody.file,\n\n        metadata: reqBody.metadata,\n      });\n\n      return { status: 200 };\n    }\n\n    if (!actionType || actionType !== \"upload\") {\n      // This would either be someone spamming\n      // or the AWS webhook\n\n      return { status: 404 };\n    }\n\n    try {\n      const { files } = reqBody as { files: string[] };\n      // @ts-expect-error TODO: Fix this\n      const metadata = await uploadable._def.middleware(req, res);\n\n      // Validate without Zod (for now)\n      if (!Array.isArray(files) || !files.every((f) => typeof f === \"string\"))\n        throw new Error(\"Need file array\");\n\n      // FILL THE ROUTE CONFIG so the server only has one happy path\n      const parsedConfig = parseAndExpandInputConfig(\n        uploadable._def.routerConfig,\n      );\n\n      const limitHit = fileCountLimitHit(files, parsedConfig);\n\n      if (limitHit) throw new Error(\"Too many files\");\n\n      const uploadthingApiResponse = await fetch(\n        generateUploadThingURL(\"/api/prepareUpload\"),\n        {\n          method: \"POST\",\n          body: JSON.stringify({\n            files: files,\n\n            routeConfig: parsedConfig,\n\n            metadata,\n            callbackUrl: config?.callbackUrl ?? GET_DEFAULT_URL(),\n            callbackSlug: slug,\n          }),\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"x-uploadthing-api-key\": preferredOrEnvSecret,\n            \"x-uploadthing-version\": UPLOADTHING_VERSION,\n          },\n        },\n      );\n\n      if (!uploadthingApiResponse.ok) {\n        console.error(\"[UT] unable to get presigned urls\");\n        try {\n          const error = (await uploadthingApiResponse.json()) as unknown;\n          console.error(error);\n        } catch (e) {\n          console.error(\"[UT] unable to parse response\");\n        }\n        throw new Error(\"ending upload\");\n      }\n\n      // This is when we send the response back to the user's form so they can submit the files\n      const parsedResponse = (await uploadthingApiResponse.json()) as {\n        presignedUrl: { url: string; fields: Record<string, string> }; // ripped type from S3 package\n        name: string;\n        key: string;\n      }[];\n\n      if (process.env.NODE_ENV === \"development\") {\n        for (const file of parsedResponse) {\n          void conditionalDevServer(file.key);\n        }\n      }\n\n      return { body: parsedResponse, status: 200 };\n    } catch (e) {\n      console.error(\"[UT] middleware failed to run\");\n      console.error(e);\n\n      return { status: 400, message: (e as Error).toString() };\n    }\n  };\n};\n\nexport const buildPermissionsInfoHandler = <TRouter extends FileRouter>(\n  opts: RouterWithConfig<TRouter>,\n) => {\n  return () => {\n    const r = opts.router;\n\n    const permissions = Object.keys(r).map((k) => {\n      const route = r[k];\n      const config = parseAndExpandInputConfig(route._def.routerConfig);\n      return {\n        slug: k as keyof TRouter,\n        config,\n      };\n    });\n\n    return permissions;\n  };\n};\n","import { createBuilder } from \"./src/upload-builder\";\n\nexport * from \"./src/types\";\nexport * as utapi from \"./src/helper-functions\";\n\nexport const createUploadthing = () => createBuilder<\"web\">();\n"],"mappings":"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","names":[]}