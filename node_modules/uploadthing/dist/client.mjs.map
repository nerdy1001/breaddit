{"version":3,"sources":["../client.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-argument */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\nimport type { FileRouter } from \"./server\";\n\nconst createRequestPermsUrl = (config: { url?: string; slug: string }) => {\n  const queryParams = `?actionType=upload&slug=${config.slug}`;\n\n  return `${config?.url ?? \"/api/uploadthing\"}${queryParams}`;\n};\n\nexport const DANGEROUS__uploadFiles = async <T extends string>(\n  files: File[],\n  endpoint: T,\n  config?: {\n    url?: string;\n  },\n) => {\n  // Get presigned URL for S3 upload\n  const s3ConnectionRes = await fetch(\n    createRequestPermsUrl({ url: config?.url, slug: endpoint }),\n    {\n      method: \"POST\",\n      body: JSON.stringify({\n        files: files.map((f) => f.name),\n      }),\n    },\n  ).then((res) => {\n    // check for 200 response\n    if (!res.ok) throw new Error(\"Failed to get presigned URLs\");\n\n    // attempt to parse response\n    try {\n      return res.json();\n    } catch (e) {\n      // response is not JSON\n      console.error(e);\n      throw new Error(`Failed to parse response as JSON. Got: ${res.body}`);\n    }\n  });\n\n  if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes))\n    throw \"No url received. How did you get here?\";\n\n  const fileUploadPromises = s3ConnectionRes.map(async (presigned: any) => {\n    const file = files.find((f) => f.name === presigned.name);\n\n    if (!file) {\n      console.error(\"No file found for presigned URL\", presigned);\n      throw new Error(\"No file found for presigned URL\");\n    }\n    const { url, fields } = presigned.presignedUrl;\n    const formData = new FormData();\n\n    // Give content type to blobs because S3 is dumb\n    // check if content-type is one of the allowed types, or if not and blobs are allowed, use application/octet-stream\n    if (presigned.fileType === file.type.split(\"/\")[0]) {\n      formData.append(\"Content-Type\", file.type);\n      console.log(\"FILE TYPE\", file.type);\n    } else if (presigned.fileType === \"blob\") {\n      formData.append(\"Content-Type\", \"application/octet-stream\");\n      console.log(\"COERCING FILE TYPE TO BLOB\");\n      console.log(\"FILE TYPE\", \"application/octet-stream\");\n    }\n\n    // Dump all values from response (+ the file itself) into form for S3 upload\n    Object.entries({ ...fields, file: file }).forEach(([key, value]) => {\n      formData.append(key, value as Blob);\n    });\n\n    // Do S3 upload\n    const upload = await fetch(url, {\n      method: \"POST\",\n      body: formData,\n      headers: new Headers({\n        Accept: \"application/xml\",\n      }),\n    });\n\n    if (!upload.ok) throw new Error(\"Upload failed.\");\n    // Generate a URL for the uploaded image since AWS won't give me one\n    const genUrl =\n      \"https://uploadthing.com/f/\" + encodeURIComponent(fields[\"key\"]);\n\n    console.log(\"URL for uploaded image\", genUrl);\n\n    return {\n      fileKey: presigned.key,\n      fileUrl: genUrl,\n    };\n  });\n\n  return Promise.all(fileUploadPromises) as Promise<\n    { fileUrl: string; fileKey: string }[]\n  >;\n};\n\nexport type UploadFileType<T extends string> = typeof DANGEROUS__uploadFiles<T>;\n\nexport const genUploader = <\n  TRouter extends FileRouter,\n>(): typeof DANGEROUS__uploadFiles<\n  keyof TRouter extends string ? keyof TRouter : string\n> => {\n  return DANGEROUS__uploadFiles;\n};\n\nexport const classNames = (...classes: string[]) => {\n  return classes.filter(Boolean).join(\" \");\n};\n\nexport const generateMimeTypes = (fileTypes: string[]) => {\n  const accepted = fileTypes.map((type) =>\n    type !== \"blob\" ? `${type}/*` : \"blob\",\n  );\n\n  if (accepted.includes(\"blob\")) {\n    return undefined;\n  }\n  return accepted;\n};\n\nexport const generateClientDropzoneAccept = (fileTypes: string[]) => {\n  const mimeTypes = generateMimeTypes(fileTypes);\n\n  if (!mimeTypes) return undefined;\n\n  return Object.fromEntries(mimeTypes.map((type) => [type, []]));\n};\n"],"mappings":";AAKA,IAAM,wBAAwB,CAAC,WAA2C;AACxE,QAAM,cAAc,2BAA2B,OAAO;AAEtD,SAAO,IAAG,iCAAQ,QAAO,qBAAqB;AAChD;AAEO,IAAM,yBAAyB,OACpC,OACA,UACA,WAGG;AAEH,QAAM,kBAAkB,MAAM;AAAA,IAC5B,sBAAsB,EAAE,KAAK,iCAAQ,KAAK,MAAM,SAAS,CAAC;AAAA,IAC1D;AAAA,MACE,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU;AAAA,QACnB,OAAO,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI;AAAA,MAChC,CAAC;AAAA,IACH;AAAA,EACF,EAAE,KAAK,CAAC,QAAQ;AAEd,QAAI,CAAC,IAAI;AAAI,YAAM,IAAI,MAAM,8BAA8B;AAG3D,QAAI;AACF,aAAO,IAAI,KAAK;AAAA,IAClB,SAAS,GAAP;AAEA,cAAQ,MAAM,CAAC;AACf,YAAM,IAAI,MAAM,0CAA0C,IAAI,MAAM;AAAA,IACtE;AAAA,EACF,CAAC;AAED,MAAI,CAAC,mBAAmB,CAAC,MAAM,QAAQ,eAAe;AACpD,UAAM;AAER,QAAM,qBAAqB,gBAAgB,IAAI,OAAO,cAAmB;AACvE,UAAM,OAAO,MAAM,KAAK,CAAC,MAAM,EAAE,SAAS,UAAU,IAAI;AAExD,QAAI,CAAC,MAAM;AACT,cAAQ,MAAM,mCAAmC,SAAS;AAC1D,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACnD;AACA,UAAM,EAAE,KAAK,OAAO,IAAI,UAAU;AAClC,UAAM,WAAW,IAAI,SAAS;AAI9B,QAAI,UAAU,aAAa,KAAK,KAAK,MAAM,GAAG,EAAE,CAAC,GAAG;AAClD,eAAS,OAAO,gBAAgB,KAAK,IAAI;AACzC,cAAQ,IAAI,aAAa,KAAK,IAAI;AAAA,IACpC,WAAW,UAAU,aAAa,QAAQ;AACxC,eAAS,OAAO,gBAAgB,0BAA0B;AAC1D,cAAQ,IAAI,4BAA4B;AACxC,cAAQ,IAAI,aAAa,0BAA0B;AAAA,IACrD;AAGA,WAAO,QAAQ,EAAE,GAAG,QAAQ,KAAW,CAAC,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAClE,eAAS,OAAO,KAAK,KAAa;AAAA,IACpC,CAAC;AAGD,UAAM,SAAS,MAAM,MAAM,KAAK;AAAA,MAC9B,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS,IAAI,QAAQ;AAAA,QACnB,QAAQ;AAAA,MACV,CAAC;AAAA,IACH,CAAC;AAED,QAAI,CAAC,OAAO;AAAI,YAAM,IAAI,MAAM,gBAAgB;AAEhD,UAAM,SACJ,+BAA+B,mBAAmB,OAAO,KAAK,CAAC;AAEjE,YAAQ,IAAI,0BAA0B,MAAM;AAE5C,WAAO;AAAA,MACL,SAAS,UAAU;AAAA,MACnB,SAAS;AAAA,IACX;AAAA,EACF,CAAC;AAED,SAAO,QAAQ,IAAI,kBAAkB;AAGvC;AAIO,IAAM,cAAc,MAItB;AACH,SAAO;AACT;AAEO,IAAM,aAAa,IAAI,YAAsB;AAClD,SAAO,QAAQ,OAAO,OAAO,EAAE,KAAK,GAAG;AACzC;AAEO,IAAM,oBAAoB,CAAC,cAAwB;AACxD,QAAM,WAAW,UAAU;AAAA,IAAI,CAAC,SAC9B,SAAS,SAAS,GAAG,WAAW;AAAA,EAClC;AAEA,MAAI,SAAS,SAAS,MAAM,GAAG;AAC7B,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,IAAM,+BAA+B,CAAC,cAAwB;AACnE,QAAM,YAAY,kBAAkB,SAAS;AAE7C,MAAI,CAAC;AAAW,WAAO;AAEvB,SAAO,OAAO,YAAY,UAAU,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC/D;","names":[]}