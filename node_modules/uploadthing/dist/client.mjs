// client.ts
var createRequestPermsUrl = (config) => {
  const queryParams = `?actionType=upload&slug=${config.slug}`;
  return `${(config == null ? void 0 : config.url) ?? "/api/uploadthing"}${queryParams}`;
};
var DANGEROUS__uploadFiles = async (files, endpoint, config) => {
  const s3ConnectionRes = await fetch(
    createRequestPermsUrl({ url: config == null ? void 0 : config.url, slug: endpoint }),
    {
      method: "POST",
      body: JSON.stringify({
        files: files.map((f) => f.name)
      })
    }
  ).then((res) => {
    if (!res.ok)
      throw new Error("Failed to get presigned URLs");
    try {
      return res.json();
    } catch (e) {
      console.error(e);
      throw new Error(`Failed to parse response as JSON. Got: ${res.body}`);
    }
  });
  if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes))
    throw "No url received. How did you get here?";
  const fileUploadPromises = s3ConnectionRes.map(async (presigned) => {
    const file = files.find((f) => f.name === presigned.name);
    if (!file) {
      console.error("No file found for presigned URL", presigned);
      throw new Error("No file found for presigned URL");
    }
    const { url, fields } = presigned.presignedUrl;
    const formData = new FormData();
    if (presigned.fileType === file.type.split("/")[0]) {
      formData.append("Content-Type", file.type);
      console.log("FILE TYPE", file.type);
    } else if (presigned.fileType === "blob") {
      formData.append("Content-Type", "application/octet-stream");
      console.log("COERCING FILE TYPE TO BLOB");
      console.log("FILE TYPE", "application/octet-stream");
    }
    Object.entries({ ...fields, file }).forEach(([key, value]) => {
      formData.append(key, value);
    });
    const upload = await fetch(url, {
      method: "POST",
      body: formData,
      headers: new Headers({
        Accept: "application/xml"
      })
    });
    if (!upload.ok)
      throw new Error("Upload failed.");
    const genUrl = "https://uploadthing.com/f/" + encodeURIComponent(fields["key"]);
    console.log("URL for uploaded image", genUrl);
    return {
      fileKey: presigned.key,
      fileUrl: genUrl
    };
  });
  return Promise.all(fileUploadPromises);
};
var genUploader = () => {
  return DANGEROUS__uploadFiles;
};
var classNames = (...classes) => {
  return classes.filter(Boolean).join(" ");
};
var generateMimeTypes = (fileTypes) => {
  const accepted = fileTypes.map(
    (type) => type !== "blob" ? `${type}/*` : "blob"
  );
  if (accepted.includes("blob")) {
    return void 0;
  }
  return accepted;
};
var generateClientDropzoneAccept = (fileTypes) => {
  const mimeTypes = generateMimeTypes(fileTypes);
  if (!mimeTypes)
    return void 0;
  return Object.fromEntries(mimeTypes.map((type) => [type, []]));
};
export {
  DANGEROUS__uploadFiles,
  classNames,
  genUploader,
  generateClientDropzoneAccept,
  generateMimeTypes
};
//# sourceMappingURL=client.mjs.map